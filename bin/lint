#!/usr/bin/env ruby
require 'open3'
require 'fileutils'

class LintRunner
  def initialize
    @results = {}
    @total_errors = 0
    @total_warnings = 0
    @start_time = Time.now
    @mutex = Mutex.new

    # Ensure RuboCop cache writes to a workspace-writable location
    @rubocop_cache_root = File.join(Dir.pwd, 'tmp', '.rubocop_cache')
    FileUtils.mkdir_p(@rubocop_cache_root)
    ENV['RUBOCOP_CACHE_ROOT'] = @rubocop_cache_root
  end

  def run_all
    puts "üîç Running all linters in parallel...\n"
    puts "=" * 60

    # Run all linters in parallel using threads
    threads = []
    
    threads << Thread.new { run_rubocop }
    threads << Thread.new { run_brakeman }
    threads << Thread.new { run_erb_lint }
    threads << Thread.new { run_js_lint }
    threads << Thread.new { run_dockerfile_lint }
    threads << Thread.new { run_yaml_lint }
    
    # Wait for all threads to complete
    threads.each(&:join)

    print_summary
  end

  def fix_all
    puts "üîß Auto-fixing all linters in parallel...\n"
    puts "=" * 60

    # Run auto-fix commands in parallel
    threads = []
    
    threads << Thread.new { fix_rubocop }
    threads << Thread.new { fix_erb_lint }
    threads << Thread.new { fix_js_lint }
    
    # Wait for all threads to complete
    threads.each(&:join)

    puts "\n‚úÖ Auto-fix completed! Running linters to verify...\n"
    run_all
  end

  private

  def run_rubocop
    @mutex.synchronize { puts "\nüìù Running RuboCop (Ruby linting)..." }
    result = run_command("bundle exec rubocop --format=progress --cache-root #{@rubocop_cache_root}")
    @mutex.synchronize do
      @results[:rubocop] = result
      print_result('RuboCop', result)
    end
  end

  def run_brakeman
    @mutex.synchronize { puts "\nüîí Running Brakeman (Security analysis)..." }
    result = run_command('bundle exec brakeman --quiet --format=json --ignore-config config/brakeman.ignore')
    @mutex.synchronize do
      @results[:brakeman] = result
      print_result('Brakeman', result)
    end
  end

  def run_erb_lint
    @mutex.synchronize { puts "\nüìÑ Running ERB Lint (Template linting)..." }
    result = run_command('bundle exec erb_lint --lint-all --format=compact')
    @mutex.synchronize do
      @results[:erb_lint] = result
      print_result('ERB Lint', result)
    end
  end

  def run_js_lint
    @mutex.synchronize { puts "\n‚ö° Running ESLint (JavaScript linting)..." }
    result = run_command('npm run lint:js')
    @mutex.synchronize do
      @results[:js_lint] = result
      print_result('ESLint', result)
    end
  end

  def run_dockerfile_lint
    @mutex.synchronize { puts "\nüê≥ Running Hadolint (Dockerfile linting)..." }
    result = run_command('bin/linters/hadolint --config .hadolint.yaml Dockerfile')
    @mutex.synchronize do
      @results[:dockerfile_lint] = result
      print_result('Hadolint', result)
    end
  end

  def run_yaml_lint
    @mutex.synchronize { puts "\nüìã Running YAML Lint (YAML file linting)..." }
    # Lint main config YAML files, excluding test fixtures and generated files
    yaml_files = %w[
      config/*.yml
      .github/workflows/*.yml
    ].flat_map { |pattern| Dir.glob(pattern) }.join(' ')

    if yaml_files.empty?
      @mutex.synchronize do
        @results[:yaml_lint] = { success: true, stdout: "No YAML files found to lint", stderr: "", command: "yaml-lint" }
        print_result('YAML Lint', @results[:yaml_lint])
      end
    else
      result = run_command("npx yaml-lint #{yaml_files}")
      @mutex.synchronize do
        @results[:yaml_lint] = result
        print_result('YAML Lint', result)
      end
    end
  end

  def fix_rubocop
    @mutex.synchronize { puts "\nüîß Auto-fixing RuboCop (Ruby linting)..." }
    result = run_command("bundle exec rubocop -A --cache-root #{@rubocop_cache_root}")
    @mutex.synchronize do
      if result[:success]
        puts "‚úÖ RuboCop: Auto-fix completed"
      else
        puts "‚ùå RuboCop: Auto-fix failed"
        puts "   #{result[:stderr]}" if result[:stderr] && !result[:stderr].empty?
      end
    end
  end

  def fix_erb_lint
    @mutex.synchronize { puts "\nüîß Auto-fixing ERB Lint (Template linting)..." }
    result = run_command('bundle exec erb_lint --lint-all -a')
    @mutex.synchronize do
      if result[:success]
        puts "‚úÖ ERB Lint: Auto-fix completed"
      else
        puts "‚ùå ERB Lint: Auto-fix failed"
        puts "   #{result[:stderr]}" if result[:stderr] && !result[:stderr].empty?
      end
    end
  end

  def fix_js_lint
    @mutex.synchronize { puts "\nüîß Auto-fixing ESLint (JavaScript linting)..." }
    result = run_command('npm run lint:js:fix')
    @mutex.synchronize do
      if result[:success]
        puts "‚úÖ ESLint: Auto-fix completed"
      else
        puts "‚ùå ESLint: Auto-fix failed"
        puts "   #{result[:stderr]}" if result[:stderr] && !result[:stderr].empty?
      end
    end
  end

  def run_command(command)
    stdout, stderr, status = Open3.capture3(command)
    {
      command: command,
      stdout: stdout,
      stderr: stderr,
      status: status,
      success: status.success?
    }
  end

  def print_result(name, result)
    if result[:success]
      puts "‚úÖ #{name}: No issues found"
    else
      puts "‚ùå #{name}: Issues found"
      
      # Parse and count issues
      output = result[:stdout] + result[:stderr]
      errors, warnings = count_issues(output, name)
      @total_errors += errors
      @total_warnings += warnings
      
      # Show first few lines of output for context
      lines = output.split("\n").first(5)
      if lines.any? { |line| line.strip != '' }
        puts "   First few issues:"
        lines.each do |line|
          next if line.strip.empty?
          puts "   #{line}"
        end
        if output.split("\n").length > 5
          puts "   ... (truncated, run individual linter for full output)"
        end
      end
    end
  end

  def count_issues(output, linter_name)
    errors = 0
    warnings = 0

    case linter_name
    when 'RuboCop'
      # RuboCop format: "1 file inspected, 2 offenses detected, 1 offense corrected"
      if match = output.match(/(\d+) offenses detected/)
        errors = match[1].to_i
      end
    when 'Brakeman'
      # Brakeman JSON output - count security warnings
      if output.include?('"warnings"')
        begin
          require 'json'
          data = JSON.parse(output)
          errors = data['warnings']&.length || 0
        rescue JSON::ParserError
          # Fallback to line counting
          errors = output.scan(/warning/).length
        end
      end
    when 'ERB Lint'
      # ERB Lint format: "1 offense detected"
      if match = output.match(/(\d+) offense/)
        errors = match[1].to_i
      end
    when 'ESLint'
      # ESLint format: "‚úñ 23 problems (0 errors, 23 warnings)"
      if match = output.match(/‚úñ (\d+) problems \((\d+) errors, (\d+) warnings\)/)
        errors = match[2].to_i
        warnings = match[3].to_i
      end
    when 'Hadolint'
      # Hadolint format: Each issue on a separate line with severity
      # Count lines that contain Dockerfile issues (e.g., "Dockerfile:18 DL3008")
      dockerfile_issues = output.scan(/^Dockerfile:\d+/)
      errors = dockerfile_issues.length
      warnings = output.scan(/\[1m\[93mwarning\[0m/).length + output.scan(/\[92minfo\[0m/).length
    when 'YAML Lint'
      # YAML Lint format: Reports errors in various formats
      if output.include?('Error') || output.include?('error')
        errors = output.scan(/error/i).length
      end
    end

    [errors, warnings]
  end

  def print_summary
    duration = Time.now - @start_time
    
    puts "\n" + "=" * 60
    puts "üìä LINTING SUMMARY"
    puts "=" * 60
    
    @results.each do |name, result|
      status = result[:success] ? "‚úÖ PASS" : "‚ùå FAIL"
      puts "#{name.to_s.ljust(15)} #{status}"
    end
    
    puts "\nüìà TOTALS:"
    puts "   Errors:   #{@total_errors}"
    puts "   Warnings: #{@total_warnings}"
    puts "   Duration: #{duration.round(2)}s"
    
    if @total_errors > 0
      puts "\nüí° TIP: Run individual linters for detailed output:"
      puts "   bundle exec rubocop          # Ruby linting"
      puts "   bundle exec brakeman         # Security analysis"
      puts "   bundle exec erb_lint         # ERB template linting"
      puts "   npm run lint:js              # JavaScript linting"
      puts "   bin/linters/hadolint Dockerfile  # Dockerfile linting"
      puts "   npx yaml-lint config/*.yml   # YAML file linting"
      puts "   npm run lint:js:fix          # Auto-fix JS issues"
    end
    
    puts "\nüéØ QUICK FIXES:"
    puts "   ./bin/lint --fix               # Auto-fix ALL issues"
    puts "   npm run lint:fix               # Auto-fix ALL issues (npm)"
    puts "   bundle exec rubocop -A         # Auto-fix Ruby issues"
    puts "   bundle exec erb_lint -a        # Auto-fix ERB issues"
    puts "   npm run lint:js:fix            # Auto-fix JS issues"
    
    # Exit with error code if any linter failed
    exit 1 if @total_errors > 0
  end
end

# Parse command line arguments
if ARGV.include?('--fix') || ARGV.include?('-f')
  LintRunner.new.fix_all
else
  LintRunner.new.run_all
end
